// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OptionTick.proto

#ifndef PROTOBUF_OptionTick_2eproto__INCLUDED
#define PROTOBUF_OptionTick_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Serializable {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_OptionTick_2eproto();
void protobuf_AssignDesc_OptionTick_2eproto();
void protobuf_ShutdownFile_OptionTick_2eproto();

class OptionTick_ser;
class Option_collection_ser;

// ===================================================================

class OptionTick_ser : public ::google::protobuf::Message {
 public:
  OptionTick_ser();
  virtual ~OptionTick_ser();

  OptionTick_ser(const OptionTick_ser& from);

  inline OptionTick_ser& operator=(const OptionTick_ser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionTick_ser& default_instance();

  void Swap(OptionTick_ser* other);

  // implements Message ----------------------------------------------

  OptionTick_ser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptionTick_ser& from);
  void MergeFrom(const OptionTick_ser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional bool isTraded = 2 [default = false];
  inline bool has_istraded() const;
  inline void clear_istraded();
  static const int kIsTradedFieldNumber = 2;
  inline bool istraded() const;
  inline void set_istraded(bool value);

  // optional bool isQuote = 3 [default = false];
  inline bool has_isquote() const;
  inline void clear_isquote();
  static const int kIsQuoteFieldNumber = 3;
  inline bool isquote() const;
  inline void set_isquote(bool value);

  // optional string isType = 4;
  inline bool has_istype() const;
  inline void clear_istype();
  static const int kIsTypeFieldNumber = 4;
  inline const ::std::string& istype() const;
  inline void set_istype(const ::std::string& value);
  inline void set_istype(const char* value);
  inline void set_istype(const char* value, size_t size);
  inline ::std::string* mutable_istype();
  inline ::std::string* release_istype();
  inline void set_allocated_istype(::std::string* istype);

  // optional float TradePrice = 5 [default = 0];
  inline bool has_tradeprice() const;
  inline void clear_tradeprice();
  static const int kTradePriceFieldNumber = 5;
  inline float tradeprice() const;
  inline void set_tradeprice(float value);

  // optional int32 TradeVolume = 6;
  inline bool has_tradevolume() const;
  inline void clear_tradevolume();
  static const int kTradeVolumeFieldNumber = 6;
  inline ::google::protobuf::int32 tradevolume() const;
  inline void set_tradevolume(::google::protobuf::int32 value);

  // optional string TradeExch = 7;
  inline bool has_tradeexch() const;
  inline void clear_tradeexch();
  static const int kTradeExchFieldNumber = 7;
  inline const ::std::string& tradeexch() const;
  inline void set_tradeexch(const ::std::string& value);
  inline void set_tradeexch(const char* value);
  inline void set_tradeexch(const char* value, size_t size);
  inline ::std::string* mutable_tradeexch();
  inline ::std::string* release_tradeexch();
  inline void set_allocated_tradeexch(::std::string* tradeexch);

  // optional float bid = 8 [default = 0];
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 8;
  inline float bid() const;
  inline void set_bid(float value);

  // optional int32 BidSize = 9 [default = 0];
  inline bool has_bidsize() const;
  inline void clear_bidsize();
  static const int kBidSizeFieldNumber = 9;
  inline ::google::protobuf::int32 bidsize() const;
  inline void set_bidsize(::google::protobuf::int32 value);

  // optional string BidExch = 10;
  inline bool has_bidexch() const;
  inline void clear_bidexch();
  static const int kBidExchFieldNumber = 10;
  inline const ::std::string& bidexch() const;
  inline void set_bidexch(const ::std::string& value);
  inline void set_bidexch(const char* value);
  inline void set_bidexch(const char* value, size_t size);
  inline ::std::string* mutable_bidexch();
  inline ::std::string* release_bidexch();
  inline void set_allocated_bidexch(::std::string* bidexch);

  // optional string BidTime = 11;
  inline bool has_bidtime() const;
  inline void clear_bidtime();
  static const int kBidTimeFieldNumber = 11;
  inline const ::std::string& bidtime() const;
  inline void set_bidtime(const ::std::string& value);
  inline void set_bidtime(const char* value);
  inline void set_bidtime(const char* value, size_t size);
  inline ::std::string* mutable_bidtime();
  inline ::std::string* release_bidtime();
  inline void set_allocated_bidtime(::std::string* bidtime);

  // optional float ask = 12 [default = 0];
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 12;
  inline float ask() const;
  inline void set_ask(float value);

  // optional int32 AskSize = 13 [default = 0];
  inline bool has_asksize() const;
  inline void clear_asksize();
  static const int kAskSizeFieldNumber = 13;
  inline ::google::protobuf::int32 asksize() const;
  inline void set_asksize(::google::protobuf::int32 value);

  // optional float AskExch = 14 [default = 0];
  inline bool has_askexch() const;
  inline void clear_askexch();
  static const int kAskExchFieldNumber = 14;
  inline float askexch() const;
  inline void set_askexch(float value);

  // optional string AskTime = 15;
  inline bool has_asktime() const;
  inline void clear_asktime();
  static const int kAskTimeFieldNumber = 15;
  inline const ::std::string& asktime() const;
  inline void set_asktime(const ::std::string& value);
  inline void set_asktime(const char* value);
  inline void set_asktime(const char* value, size_t size);
  inline ::std::string* mutable_asktime();
  inline ::std::string* release_asktime();
  inline void set_allocated_asktime(::std::string* asktime);

  // optional int32 DailyVolume = 16 [default = 0];
  inline bool has_dailyvolume() const;
  inline void clear_dailyvolume();
  static const int kDailyVolumeFieldNumber = 16;
  inline ::google::protobuf::int32 dailyvolume() const;
  inline void set_dailyvolume(::google::protobuf::int32 value);

  // optional float DailyHigh = 17 [default = 0];
  inline bool has_dailyhigh() const;
  inline void clear_dailyhigh();
  static const int kDailyHighFieldNumber = 17;
  inline float dailyhigh() const;
  inline void set_dailyhigh(float value);

  // optional float DailyLow = 18 [default = 0];
  inline bool has_dailylow() const;
  inline void clear_dailylow();
  static const int kDailyLowFieldNumber = 18;
  inline float dailylow() const;
  inline void set_dailylow(float value);

  // optional int32 DailyTrades = 19 [default = 0];
  inline bool has_dailytrades() const;
  inline void clear_dailytrades();
  static const int kDailyTradesFieldNumber = 19;
  inline ::google::protobuf::int32 dailytrades() const;
  inline void set_dailytrades(::google::protobuf::int32 value);

  // optional string TimeStamp = 20;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 20;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional int32 OpenInterest = 21 [default = 0];
  inline bool has_openinterest() const;
  inline void clear_openinterest();
  static const int kOpenInterestFieldNumber = 21;
  inline ::google::protobuf::int32 openinterest() const;
  inline void set_openinterest(::google::protobuf::int32 value);

  // optional string ExpDate = 22;
  inline bool has_expdate() const;
  inline void clear_expdate();
  static const int kExpDateFieldNumber = 22;
  inline const ::std::string& expdate() const;
  inline void set_expdate(const ::std::string& value);
  inline void set_expdate(const char* value);
  inline void set_expdate(const char* value, size_t size);
  inline ::std::string* mutable_expdate();
  inline ::std::string* release_expdate();
  inline void set_allocated_expdate(::std::string* expdate);

  // optional float Strike = 23 [default = 0];
  inline bool has_strike() const;
  inline void clear_strike();
  static const int kStrikeFieldNumber = 23;
  inline float strike() const;
  inline void set_strike(float value);

  // optional int32 TickID = 24 [default = 0];
  inline bool has_tickid() const;
  inline void clear_tickid();
  static const int kTickIDFieldNumber = 24;
  inline ::google::protobuf::int32 tickid() const;
  inline void set_tickid(::google::protobuf::int32 value);

  // optional float Bid_Imp_volatility = 25 [default = 0];
  inline bool has_bid_imp_volatility() const;
  inline void clear_bid_imp_volatility();
  static const int kBidImpVolatilityFieldNumber = 25;
  inline float bid_imp_volatility() const;
  inline void set_bid_imp_volatility(float value);

  // optional float Ask_Imp_volatility = 26 [default = 0];
  inline bool has_ask_imp_volatility() const;
  inline void clear_ask_imp_volatility();
  static const int kAskImpVolatilityFieldNumber = 26;
  inline float ask_imp_volatility() const;
  inline void set_ask_imp_volatility(float value);

  // optional float MP_Imp_volatility = 27 [default = 0];
  inline bool has_mp_imp_volatility() const;
  inline void clear_mp_imp_volatility();
  static const int kMPImpVolatilityFieldNumber = 27;
  inline float mp_imp_volatility() const;
  inline void set_mp_imp_volatility(float value);

  // optional float Exp_Time_Left = 28 [default = 0];
  inline bool has_exp_time_left() const;
  inline void clear_exp_time_left();
  static const int kExpTimeLeftFieldNumber = 28;
  inline float exp_time_left() const;
  inline void set_exp_time_left(float value);

  // optional int32 BidTrade = 29 [default = 0];
  inline bool has_bidtrade() const;
  inline void clear_bidtrade();
  static const int kBidTradeFieldNumber = 29;
  inline ::google::protobuf::int32 bidtrade() const;
  inline void set_bidtrade(::google::protobuf::int32 value);

  // optional int32 NTrade = 30 [default = 0];
  inline bool has_ntrade() const;
  inline void clear_ntrade();
  static const int kNTradeFieldNumber = 30;
  inline ::google::protobuf::int32 ntrade() const;
  inline void set_ntrade(::google::protobuf::int32 value);

  // optional int32 AskTrade = 31 [default = 0];
  inline bool has_asktrade() const;
  inline void clear_asktrade();
  static const int kAskTradeFieldNumber = 31;
  inline ::google::protobuf::int32 asktrade() const;
  inline void set_asktrade(::google::protobuf::int32 value);

  // optional int32 BidVol = 32 [default = 0];
  inline bool has_bidvol() const;
  inline void clear_bidvol();
  static const int kBidVolFieldNumber = 32;
  inline ::google::protobuf::int32 bidvol() const;
  inline void set_bidvol(::google::protobuf::int32 value);

  // optional int32 NVol = 33 [default = 0];
  inline bool has_nvol() const;
  inline void clear_nvol();
  static const int kNVolFieldNumber = 33;
  inline ::google::protobuf::int32 nvol() const;
  inline void set_nvol(::google::protobuf::int32 value);

  // optional int32 AskVol = 34 [default = 0];
  inline bool has_askvol() const;
  inline void clear_askvol();
  static const int kAskVolFieldNumber = 34;
  inline ::google::protobuf::int32 askvol() const;
  inline void set_askvol(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Serializable.OptionTick_ser)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_istraded();
  inline void clear_has_istraded();
  inline void set_has_isquote();
  inline void clear_has_isquote();
  inline void set_has_istype();
  inline void clear_has_istype();
  inline void set_has_tradeprice();
  inline void clear_has_tradeprice();
  inline void set_has_tradevolume();
  inline void clear_has_tradevolume();
  inline void set_has_tradeexch();
  inline void clear_has_tradeexch();
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_bidsize();
  inline void clear_has_bidsize();
  inline void set_has_bidexch();
  inline void clear_has_bidexch();
  inline void set_has_bidtime();
  inline void clear_has_bidtime();
  inline void set_has_ask();
  inline void clear_has_ask();
  inline void set_has_asksize();
  inline void clear_has_asksize();
  inline void set_has_askexch();
  inline void clear_has_askexch();
  inline void set_has_asktime();
  inline void clear_has_asktime();
  inline void set_has_dailyvolume();
  inline void clear_has_dailyvolume();
  inline void set_has_dailyhigh();
  inline void clear_has_dailyhigh();
  inline void set_has_dailylow();
  inline void clear_has_dailylow();
  inline void set_has_dailytrades();
  inline void clear_has_dailytrades();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_openinterest();
  inline void clear_has_openinterest();
  inline void set_has_expdate();
  inline void clear_has_expdate();
  inline void set_has_strike();
  inline void clear_has_strike();
  inline void set_has_tickid();
  inline void clear_has_tickid();
  inline void set_has_bid_imp_volatility();
  inline void clear_has_bid_imp_volatility();
  inline void set_has_ask_imp_volatility();
  inline void clear_has_ask_imp_volatility();
  inline void set_has_mp_imp_volatility();
  inline void clear_has_mp_imp_volatility();
  inline void set_has_exp_time_left();
  inline void clear_has_exp_time_left();
  inline void set_has_bidtrade();
  inline void clear_has_bidtrade();
  inline void set_has_ntrade();
  inline void clear_has_ntrade();
  inline void set_has_asktrade();
  inline void clear_has_asktrade();
  inline void set_has_bidvol();
  inline void clear_has_bidvol();
  inline void set_has_nvol();
  inline void clear_has_nvol();
  inline void set_has_askvol();
  inline void clear_has_askvol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* symbol_;
  bool istraded_;
  bool isquote_;
  float tradeprice_;
  ::std::string* istype_;
  ::std::string* tradeexch_;
  ::google::protobuf::int32 tradevolume_;
  float bid_;
  ::std::string* bidexch_;
  ::google::protobuf::int32 bidsize_;
  float ask_;
  ::std::string* bidtime_;
  ::google::protobuf::int32 asksize_;
  float askexch_;
  ::std::string* asktime_;
  ::google::protobuf::int32 dailyvolume_;
  float dailyhigh_;
  float dailylow_;
  ::google::protobuf::int32 dailytrades_;
  ::std::string* timestamp_;
  ::std::string* expdate_;
  ::google::protobuf::int32 openinterest_;
  float strike_;
  ::google::protobuf::int32 tickid_;
  float bid_imp_volatility_;
  float ask_imp_volatility_;
  float mp_imp_volatility_;
  float exp_time_left_;
  ::google::protobuf::int32 bidtrade_;
  ::google::protobuf::int32 ntrade_;
  ::google::protobuf::int32 asktrade_;
  ::google::protobuf::int32 bidvol_;
  ::google::protobuf::int32 nvol_;
  ::google::protobuf::int32 askvol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(34 + 31) / 32];

  friend void  protobuf_AddDesc_OptionTick_2eproto();
  friend void protobuf_AssignDesc_OptionTick_2eproto();
  friend void protobuf_ShutdownFile_OptionTick_2eproto();

  void InitAsDefaultInstance();
  static OptionTick_ser* default_instance_;
};
// -------------------------------------------------------------------

class Option_collection_ser : public ::google::protobuf::Message {
 public:
  Option_collection_ser();
  virtual ~Option_collection_ser();

  Option_collection_ser(const Option_collection_ser& from);

  inline Option_collection_ser& operator=(const Option_collection_ser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Option_collection_ser& default_instance();

  void Swap(Option_collection_ser* other);

  // implements Message ----------------------------------------------

  Option_collection_ser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Option_collection_ser& from);
  void MergeFrom(const Option_collection_ser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Serializable.OptionTick_ser option_tick_collection = 1;
  inline int option_tick_collection_size() const;
  inline void clear_option_tick_collection();
  static const int kOptionTickCollectionFieldNumber = 1;
  inline const ::Serializable::OptionTick_ser& option_tick_collection(int index) const;
  inline ::Serializable::OptionTick_ser* mutable_option_tick_collection(int index);
  inline ::Serializable::OptionTick_ser* add_option_tick_collection();
  inline const ::google::protobuf::RepeatedPtrField< ::Serializable::OptionTick_ser >&
      option_tick_collection() const;
  inline ::google::protobuf::RepeatedPtrField< ::Serializable::OptionTick_ser >*
      mutable_option_tick_collection();

  // @@protoc_insertion_point(class_scope:Serializable.Option_collection_ser)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Serializable::OptionTick_ser > option_tick_collection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OptionTick_2eproto();
  friend void protobuf_AssignDesc_OptionTick_2eproto();
  friend void protobuf_ShutdownFile_OptionTick_2eproto();

  void InitAsDefaultInstance();
  static Option_collection_ser* default_instance_;
};
// ===================================================================


// ===================================================================

// OptionTick_ser

// required string symbol = 1;
inline bool OptionTick_ser::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OptionTick_ser::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OptionTick_ser::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OptionTick_ser::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& OptionTick_ser::symbol() const {
  return *symbol_;
}
inline void OptionTick_ser::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OptionTick_ser::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OptionTick_ser::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* OptionTick_ser::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isTraded = 2 [default = false];
inline bool OptionTick_ser::has_istraded() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OptionTick_ser::set_has_istraded() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OptionTick_ser::clear_has_istraded() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OptionTick_ser::clear_istraded() {
  istraded_ = false;
  clear_has_istraded();
}
inline bool OptionTick_ser::istraded() const {
  return istraded_;
}
inline void OptionTick_ser::set_istraded(bool value) {
  set_has_istraded();
  istraded_ = value;
}

// optional bool isQuote = 3 [default = false];
inline bool OptionTick_ser::has_isquote() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OptionTick_ser::set_has_isquote() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OptionTick_ser::clear_has_isquote() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OptionTick_ser::clear_isquote() {
  isquote_ = false;
  clear_has_isquote();
}
inline bool OptionTick_ser::isquote() const {
  return isquote_;
}
inline void OptionTick_ser::set_isquote(bool value) {
  set_has_isquote();
  isquote_ = value;
}

// optional string isType = 4;
inline bool OptionTick_ser::has_istype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OptionTick_ser::set_has_istype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OptionTick_ser::clear_has_istype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OptionTick_ser::clear_istype() {
  if (istype_ != &::google::protobuf::internal::kEmptyString) {
    istype_->clear();
  }
  clear_has_istype();
}
inline const ::std::string& OptionTick_ser::istype() const {
  return *istype_;
}
inline void OptionTick_ser::set_istype(const ::std::string& value) {
  set_has_istype();
  if (istype_ == &::google::protobuf::internal::kEmptyString) {
    istype_ = new ::std::string;
  }
  istype_->assign(value);
}
inline void OptionTick_ser::set_istype(const char* value) {
  set_has_istype();
  if (istype_ == &::google::protobuf::internal::kEmptyString) {
    istype_ = new ::std::string;
  }
  istype_->assign(value);
}
inline void OptionTick_ser::set_istype(const char* value, size_t size) {
  set_has_istype();
  if (istype_ == &::google::protobuf::internal::kEmptyString) {
    istype_ = new ::std::string;
  }
  istype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_istype() {
  set_has_istype();
  if (istype_ == &::google::protobuf::internal::kEmptyString) {
    istype_ = new ::std::string;
  }
  return istype_;
}
inline ::std::string* OptionTick_ser::release_istype() {
  clear_has_istype();
  if (istype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = istype_;
    istype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_istype(::std::string* istype) {
  if (istype_ != &::google::protobuf::internal::kEmptyString) {
    delete istype_;
  }
  if (istype) {
    set_has_istype();
    istype_ = istype;
  } else {
    clear_has_istype();
    istype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float TradePrice = 5 [default = 0];
inline bool OptionTick_ser::has_tradeprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OptionTick_ser::set_has_tradeprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OptionTick_ser::clear_has_tradeprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OptionTick_ser::clear_tradeprice() {
  tradeprice_ = 0;
  clear_has_tradeprice();
}
inline float OptionTick_ser::tradeprice() const {
  return tradeprice_;
}
inline void OptionTick_ser::set_tradeprice(float value) {
  set_has_tradeprice();
  tradeprice_ = value;
}

// optional int32 TradeVolume = 6;
inline bool OptionTick_ser::has_tradevolume() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OptionTick_ser::set_has_tradevolume() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OptionTick_ser::clear_has_tradevolume() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OptionTick_ser::clear_tradevolume() {
  tradevolume_ = 0;
  clear_has_tradevolume();
}
inline ::google::protobuf::int32 OptionTick_ser::tradevolume() const {
  return tradevolume_;
}
inline void OptionTick_ser::set_tradevolume(::google::protobuf::int32 value) {
  set_has_tradevolume();
  tradevolume_ = value;
}

// optional string TradeExch = 7;
inline bool OptionTick_ser::has_tradeexch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OptionTick_ser::set_has_tradeexch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OptionTick_ser::clear_has_tradeexch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OptionTick_ser::clear_tradeexch() {
  if (tradeexch_ != &::google::protobuf::internal::kEmptyString) {
    tradeexch_->clear();
  }
  clear_has_tradeexch();
}
inline const ::std::string& OptionTick_ser::tradeexch() const {
  return *tradeexch_;
}
inline void OptionTick_ser::set_tradeexch(const ::std::string& value) {
  set_has_tradeexch();
  if (tradeexch_ == &::google::protobuf::internal::kEmptyString) {
    tradeexch_ = new ::std::string;
  }
  tradeexch_->assign(value);
}
inline void OptionTick_ser::set_tradeexch(const char* value) {
  set_has_tradeexch();
  if (tradeexch_ == &::google::protobuf::internal::kEmptyString) {
    tradeexch_ = new ::std::string;
  }
  tradeexch_->assign(value);
}
inline void OptionTick_ser::set_tradeexch(const char* value, size_t size) {
  set_has_tradeexch();
  if (tradeexch_ == &::google::protobuf::internal::kEmptyString) {
    tradeexch_ = new ::std::string;
  }
  tradeexch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_tradeexch() {
  set_has_tradeexch();
  if (tradeexch_ == &::google::protobuf::internal::kEmptyString) {
    tradeexch_ = new ::std::string;
  }
  return tradeexch_;
}
inline ::std::string* OptionTick_ser::release_tradeexch() {
  clear_has_tradeexch();
  if (tradeexch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradeexch_;
    tradeexch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_tradeexch(::std::string* tradeexch) {
  if (tradeexch_ != &::google::protobuf::internal::kEmptyString) {
    delete tradeexch_;
  }
  if (tradeexch) {
    set_has_tradeexch();
    tradeexch_ = tradeexch;
  } else {
    clear_has_tradeexch();
    tradeexch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float bid = 8 [default = 0];
inline bool OptionTick_ser::has_bid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OptionTick_ser::set_has_bid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OptionTick_ser::clear_has_bid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OptionTick_ser::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline float OptionTick_ser::bid() const {
  return bid_;
}
inline void OptionTick_ser::set_bid(float value) {
  set_has_bid();
  bid_ = value;
}

// optional int32 BidSize = 9 [default = 0];
inline bool OptionTick_ser::has_bidsize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OptionTick_ser::set_has_bidsize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OptionTick_ser::clear_has_bidsize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OptionTick_ser::clear_bidsize() {
  bidsize_ = 0;
  clear_has_bidsize();
}
inline ::google::protobuf::int32 OptionTick_ser::bidsize() const {
  return bidsize_;
}
inline void OptionTick_ser::set_bidsize(::google::protobuf::int32 value) {
  set_has_bidsize();
  bidsize_ = value;
}

// optional string BidExch = 10;
inline bool OptionTick_ser::has_bidexch() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OptionTick_ser::set_has_bidexch() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OptionTick_ser::clear_has_bidexch() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OptionTick_ser::clear_bidexch() {
  if (bidexch_ != &::google::protobuf::internal::kEmptyString) {
    bidexch_->clear();
  }
  clear_has_bidexch();
}
inline const ::std::string& OptionTick_ser::bidexch() const {
  return *bidexch_;
}
inline void OptionTick_ser::set_bidexch(const ::std::string& value) {
  set_has_bidexch();
  if (bidexch_ == &::google::protobuf::internal::kEmptyString) {
    bidexch_ = new ::std::string;
  }
  bidexch_->assign(value);
}
inline void OptionTick_ser::set_bidexch(const char* value) {
  set_has_bidexch();
  if (bidexch_ == &::google::protobuf::internal::kEmptyString) {
    bidexch_ = new ::std::string;
  }
  bidexch_->assign(value);
}
inline void OptionTick_ser::set_bidexch(const char* value, size_t size) {
  set_has_bidexch();
  if (bidexch_ == &::google::protobuf::internal::kEmptyString) {
    bidexch_ = new ::std::string;
  }
  bidexch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_bidexch() {
  set_has_bidexch();
  if (bidexch_ == &::google::protobuf::internal::kEmptyString) {
    bidexch_ = new ::std::string;
  }
  return bidexch_;
}
inline ::std::string* OptionTick_ser::release_bidexch() {
  clear_has_bidexch();
  if (bidexch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bidexch_;
    bidexch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_bidexch(::std::string* bidexch) {
  if (bidexch_ != &::google::protobuf::internal::kEmptyString) {
    delete bidexch_;
  }
  if (bidexch) {
    set_has_bidexch();
    bidexch_ = bidexch;
  } else {
    clear_has_bidexch();
    bidexch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string BidTime = 11;
inline bool OptionTick_ser::has_bidtime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OptionTick_ser::set_has_bidtime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OptionTick_ser::clear_has_bidtime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OptionTick_ser::clear_bidtime() {
  if (bidtime_ != &::google::protobuf::internal::kEmptyString) {
    bidtime_->clear();
  }
  clear_has_bidtime();
}
inline const ::std::string& OptionTick_ser::bidtime() const {
  return *bidtime_;
}
inline void OptionTick_ser::set_bidtime(const ::std::string& value) {
  set_has_bidtime();
  if (bidtime_ == &::google::protobuf::internal::kEmptyString) {
    bidtime_ = new ::std::string;
  }
  bidtime_->assign(value);
}
inline void OptionTick_ser::set_bidtime(const char* value) {
  set_has_bidtime();
  if (bidtime_ == &::google::protobuf::internal::kEmptyString) {
    bidtime_ = new ::std::string;
  }
  bidtime_->assign(value);
}
inline void OptionTick_ser::set_bidtime(const char* value, size_t size) {
  set_has_bidtime();
  if (bidtime_ == &::google::protobuf::internal::kEmptyString) {
    bidtime_ = new ::std::string;
  }
  bidtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_bidtime() {
  set_has_bidtime();
  if (bidtime_ == &::google::protobuf::internal::kEmptyString) {
    bidtime_ = new ::std::string;
  }
  return bidtime_;
}
inline ::std::string* OptionTick_ser::release_bidtime() {
  clear_has_bidtime();
  if (bidtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bidtime_;
    bidtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_bidtime(::std::string* bidtime) {
  if (bidtime_ != &::google::protobuf::internal::kEmptyString) {
    delete bidtime_;
  }
  if (bidtime) {
    set_has_bidtime();
    bidtime_ = bidtime;
  } else {
    clear_has_bidtime();
    bidtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float ask = 12 [default = 0];
inline bool OptionTick_ser::has_ask() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OptionTick_ser::set_has_ask() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OptionTick_ser::clear_has_ask() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OptionTick_ser::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline float OptionTick_ser::ask() const {
  return ask_;
}
inline void OptionTick_ser::set_ask(float value) {
  set_has_ask();
  ask_ = value;
}

// optional int32 AskSize = 13 [default = 0];
inline bool OptionTick_ser::has_asksize() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OptionTick_ser::set_has_asksize() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OptionTick_ser::clear_has_asksize() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OptionTick_ser::clear_asksize() {
  asksize_ = 0;
  clear_has_asksize();
}
inline ::google::protobuf::int32 OptionTick_ser::asksize() const {
  return asksize_;
}
inline void OptionTick_ser::set_asksize(::google::protobuf::int32 value) {
  set_has_asksize();
  asksize_ = value;
}

// optional float AskExch = 14 [default = 0];
inline bool OptionTick_ser::has_askexch() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OptionTick_ser::set_has_askexch() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OptionTick_ser::clear_has_askexch() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OptionTick_ser::clear_askexch() {
  askexch_ = 0;
  clear_has_askexch();
}
inline float OptionTick_ser::askexch() const {
  return askexch_;
}
inline void OptionTick_ser::set_askexch(float value) {
  set_has_askexch();
  askexch_ = value;
}

// optional string AskTime = 15;
inline bool OptionTick_ser::has_asktime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OptionTick_ser::set_has_asktime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OptionTick_ser::clear_has_asktime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OptionTick_ser::clear_asktime() {
  if (asktime_ != &::google::protobuf::internal::kEmptyString) {
    asktime_->clear();
  }
  clear_has_asktime();
}
inline const ::std::string& OptionTick_ser::asktime() const {
  return *asktime_;
}
inline void OptionTick_ser::set_asktime(const ::std::string& value) {
  set_has_asktime();
  if (asktime_ == &::google::protobuf::internal::kEmptyString) {
    asktime_ = new ::std::string;
  }
  asktime_->assign(value);
}
inline void OptionTick_ser::set_asktime(const char* value) {
  set_has_asktime();
  if (asktime_ == &::google::protobuf::internal::kEmptyString) {
    asktime_ = new ::std::string;
  }
  asktime_->assign(value);
}
inline void OptionTick_ser::set_asktime(const char* value, size_t size) {
  set_has_asktime();
  if (asktime_ == &::google::protobuf::internal::kEmptyString) {
    asktime_ = new ::std::string;
  }
  asktime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_asktime() {
  set_has_asktime();
  if (asktime_ == &::google::protobuf::internal::kEmptyString) {
    asktime_ = new ::std::string;
  }
  return asktime_;
}
inline ::std::string* OptionTick_ser::release_asktime() {
  clear_has_asktime();
  if (asktime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = asktime_;
    asktime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_asktime(::std::string* asktime) {
  if (asktime_ != &::google::protobuf::internal::kEmptyString) {
    delete asktime_;
  }
  if (asktime) {
    set_has_asktime();
    asktime_ = asktime;
  } else {
    clear_has_asktime();
    asktime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 DailyVolume = 16 [default = 0];
inline bool OptionTick_ser::has_dailyvolume() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OptionTick_ser::set_has_dailyvolume() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OptionTick_ser::clear_has_dailyvolume() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OptionTick_ser::clear_dailyvolume() {
  dailyvolume_ = 0;
  clear_has_dailyvolume();
}
inline ::google::protobuf::int32 OptionTick_ser::dailyvolume() const {
  return dailyvolume_;
}
inline void OptionTick_ser::set_dailyvolume(::google::protobuf::int32 value) {
  set_has_dailyvolume();
  dailyvolume_ = value;
}

// optional float DailyHigh = 17 [default = 0];
inline bool OptionTick_ser::has_dailyhigh() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OptionTick_ser::set_has_dailyhigh() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OptionTick_ser::clear_has_dailyhigh() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OptionTick_ser::clear_dailyhigh() {
  dailyhigh_ = 0;
  clear_has_dailyhigh();
}
inline float OptionTick_ser::dailyhigh() const {
  return dailyhigh_;
}
inline void OptionTick_ser::set_dailyhigh(float value) {
  set_has_dailyhigh();
  dailyhigh_ = value;
}

// optional float DailyLow = 18 [default = 0];
inline bool OptionTick_ser::has_dailylow() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OptionTick_ser::set_has_dailylow() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OptionTick_ser::clear_has_dailylow() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OptionTick_ser::clear_dailylow() {
  dailylow_ = 0;
  clear_has_dailylow();
}
inline float OptionTick_ser::dailylow() const {
  return dailylow_;
}
inline void OptionTick_ser::set_dailylow(float value) {
  set_has_dailylow();
  dailylow_ = value;
}

// optional int32 DailyTrades = 19 [default = 0];
inline bool OptionTick_ser::has_dailytrades() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void OptionTick_ser::set_has_dailytrades() {
  _has_bits_[0] |= 0x00040000u;
}
inline void OptionTick_ser::clear_has_dailytrades() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void OptionTick_ser::clear_dailytrades() {
  dailytrades_ = 0;
  clear_has_dailytrades();
}
inline ::google::protobuf::int32 OptionTick_ser::dailytrades() const {
  return dailytrades_;
}
inline void OptionTick_ser::set_dailytrades(::google::protobuf::int32 value) {
  set_has_dailytrades();
  dailytrades_ = value;
}

// optional string TimeStamp = 20;
inline bool OptionTick_ser::has_timestamp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OptionTick_ser::set_has_timestamp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OptionTick_ser::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OptionTick_ser::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& OptionTick_ser::timestamp() const {
  return *timestamp_;
}
inline void OptionTick_ser::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void OptionTick_ser::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void OptionTick_ser::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* OptionTick_ser::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 OpenInterest = 21 [default = 0];
inline bool OptionTick_ser::has_openinterest() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void OptionTick_ser::set_has_openinterest() {
  _has_bits_[0] |= 0x00100000u;
}
inline void OptionTick_ser::clear_has_openinterest() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void OptionTick_ser::clear_openinterest() {
  openinterest_ = 0;
  clear_has_openinterest();
}
inline ::google::protobuf::int32 OptionTick_ser::openinterest() const {
  return openinterest_;
}
inline void OptionTick_ser::set_openinterest(::google::protobuf::int32 value) {
  set_has_openinterest();
  openinterest_ = value;
}

// optional string ExpDate = 22;
inline bool OptionTick_ser::has_expdate() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void OptionTick_ser::set_has_expdate() {
  _has_bits_[0] |= 0x00200000u;
}
inline void OptionTick_ser::clear_has_expdate() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void OptionTick_ser::clear_expdate() {
  if (expdate_ != &::google::protobuf::internal::kEmptyString) {
    expdate_->clear();
  }
  clear_has_expdate();
}
inline const ::std::string& OptionTick_ser::expdate() const {
  return *expdate_;
}
inline void OptionTick_ser::set_expdate(const ::std::string& value) {
  set_has_expdate();
  if (expdate_ == &::google::protobuf::internal::kEmptyString) {
    expdate_ = new ::std::string;
  }
  expdate_->assign(value);
}
inline void OptionTick_ser::set_expdate(const char* value) {
  set_has_expdate();
  if (expdate_ == &::google::protobuf::internal::kEmptyString) {
    expdate_ = new ::std::string;
  }
  expdate_->assign(value);
}
inline void OptionTick_ser::set_expdate(const char* value, size_t size) {
  set_has_expdate();
  if (expdate_ == &::google::protobuf::internal::kEmptyString) {
    expdate_ = new ::std::string;
  }
  expdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptionTick_ser::mutable_expdate() {
  set_has_expdate();
  if (expdate_ == &::google::protobuf::internal::kEmptyString) {
    expdate_ = new ::std::string;
  }
  return expdate_;
}
inline ::std::string* OptionTick_ser::release_expdate() {
  clear_has_expdate();
  if (expdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = expdate_;
    expdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OptionTick_ser::set_allocated_expdate(::std::string* expdate) {
  if (expdate_ != &::google::protobuf::internal::kEmptyString) {
    delete expdate_;
  }
  if (expdate) {
    set_has_expdate();
    expdate_ = expdate;
  } else {
    clear_has_expdate();
    expdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float Strike = 23 [default = 0];
inline bool OptionTick_ser::has_strike() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void OptionTick_ser::set_has_strike() {
  _has_bits_[0] |= 0x00400000u;
}
inline void OptionTick_ser::clear_has_strike() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void OptionTick_ser::clear_strike() {
  strike_ = 0;
  clear_has_strike();
}
inline float OptionTick_ser::strike() const {
  return strike_;
}
inline void OptionTick_ser::set_strike(float value) {
  set_has_strike();
  strike_ = value;
}

// optional int32 TickID = 24 [default = 0];
inline bool OptionTick_ser::has_tickid() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void OptionTick_ser::set_has_tickid() {
  _has_bits_[0] |= 0x00800000u;
}
inline void OptionTick_ser::clear_has_tickid() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void OptionTick_ser::clear_tickid() {
  tickid_ = 0;
  clear_has_tickid();
}
inline ::google::protobuf::int32 OptionTick_ser::tickid() const {
  return tickid_;
}
inline void OptionTick_ser::set_tickid(::google::protobuf::int32 value) {
  set_has_tickid();
  tickid_ = value;
}

// optional float Bid_Imp_volatility = 25 [default = 0];
inline bool OptionTick_ser::has_bid_imp_volatility() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void OptionTick_ser::set_has_bid_imp_volatility() {
  _has_bits_[0] |= 0x01000000u;
}
inline void OptionTick_ser::clear_has_bid_imp_volatility() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void OptionTick_ser::clear_bid_imp_volatility() {
  bid_imp_volatility_ = 0;
  clear_has_bid_imp_volatility();
}
inline float OptionTick_ser::bid_imp_volatility() const {
  return bid_imp_volatility_;
}
inline void OptionTick_ser::set_bid_imp_volatility(float value) {
  set_has_bid_imp_volatility();
  bid_imp_volatility_ = value;
}

// optional float Ask_Imp_volatility = 26 [default = 0];
inline bool OptionTick_ser::has_ask_imp_volatility() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void OptionTick_ser::set_has_ask_imp_volatility() {
  _has_bits_[0] |= 0x02000000u;
}
inline void OptionTick_ser::clear_has_ask_imp_volatility() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void OptionTick_ser::clear_ask_imp_volatility() {
  ask_imp_volatility_ = 0;
  clear_has_ask_imp_volatility();
}
inline float OptionTick_ser::ask_imp_volatility() const {
  return ask_imp_volatility_;
}
inline void OptionTick_ser::set_ask_imp_volatility(float value) {
  set_has_ask_imp_volatility();
  ask_imp_volatility_ = value;
}

// optional float MP_Imp_volatility = 27 [default = 0];
inline bool OptionTick_ser::has_mp_imp_volatility() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void OptionTick_ser::set_has_mp_imp_volatility() {
  _has_bits_[0] |= 0x04000000u;
}
inline void OptionTick_ser::clear_has_mp_imp_volatility() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void OptionTick_ser::clear_mp_imp_volatility() {
  mp_imp_volatility_ = 0;
  clear_has_mp_imp_volatility();
}
inline float OptionTick_ser::mp_imp_volatility() const {
  return mp_imp_volatility_;
}
inline void OptionTick_ser::set_mp_imp_volatility(float value) {
  set_has_mp_imp_volatility();
  mp_imp_volatility_ = value;
}

// optional float Exp_Time_Left = 28 [default = 0];
inline bool OptionTick_ser::has_exp_time_left() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void OptionTick_ser::set_has_exp_time_left() {
  _has_bits_[0] |= 0x08000000u;
}
inline void OptionTick_ser::clear_has_exp_time_left() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void OptionTick_ser::clear_exp_time_left() {
  exp_time_left_ = 0;
  clear_has_exp_time_left();
}
inline float OptionTick_ser::exp_time_left() const {
  return exp_time_left_;
}
inline void OptionTick_ser::set_exp_time_left(float value) {
  set_has_exp_time_left();
  exp_time_left_ = value;
}

// optional int32 BidTrade = 29 [default = 0];
inline bool OptionTick_ser::has_bidtrade() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void OptionTick_ser::set_has_bidtrade() {
  _has_bits_[0] |= 0x10000000u;
}
inline void OptionTick_ser::clear_has_bidtrade() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void OptionTick_ser::clear_bidtrade() {
  bidtrade_ = 0;
  clear_has_bidtrade();
}
inline ::google::protobuf::int32 OptionTick_ser::bidtrade() const {
  return bidtrade_;
}
inline void OptionTick_ser::set_bidtrade(::google::protobuf::int32 value) {
  set_has_bidtrade();
  bidtrade_ = value;
}

// optional int32 NTrade = 30 [default = 0];
inline bool OptionTick_ser::has_ntrade() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void OptionTick_ser::set_has_ntrade() {
  _has_bits_[0] |= 0x20000000u;
}
inline void OptionTick_ser::clear_has_ntrade() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void OptionTick_ser::clear_ntrade() {
  ntrade_ = 0;
  clear_has_ntrade();
}
inline ::google::protobuf::int32 OptionTick_ser::ntrade() const {
  return ntrade_;
}
inline void OptionTick_ser::set_ntrade(::google::protobuf::int32 value) {
  set_has_ntrade();
  ntrade_ = value;
}

// optional int32 AskTrade = 31 [default = 0];
inline bool OptionTick_ser::has_asktrade() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void OptionTick_ser::set_has_asktrade() {
  _has_bits_[0] |= 0x40000000u;
}
inline void OptionTick_ser::clear_has_asktrade() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void OptionTick_ser::clear_asktrade() {
  asktrade_ = 0;
  clear_has_asktrade();
}
inline ::google::protobuf::int32 OptionTick_ser::asktrade() const {
  return asktrade_;
}
inline void OptionTick_ser::set_asktrade(::google::protobuf::int32 value) {
  set_has_asktrade();
  asktrade_ = value;
}

// optional int32 BidVol = 32 [default = 0];
inline bool OptionTick_ser::has_bidvol() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void OptionTick_ser::set_has_bidvol() {
  _has_bits_[0] |= 0x80000000u;
}
inline void OptionTick_ser::clear_has_bidvol() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void OptionTick_ser::clear_bidvol() {
  bidvol_ = 0;
  clear_has_bidvol();
}
inline ::google::protobuf::int32 OptionTick_ser::bidvol() const {
  return bidvol_;
}
inline void OptionTick_ser::set_bidvol(::google::protobuf::int32 value) {
  set_has_bidvol();
  bidvol_ = value;
}

// optional int32 NVol = 33 [default = 0];
inline bool OptionTick_ser::has_nvol() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void OptionTick_ser::set_has_nvol() {
  _has_bits_[1] |= 0x00000001u;
}
inline void OptionTick_ser::clear_has_nvol() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void OptionTick_ser::clear_nvol() {
  nvol_ = 0;
  clear_has_nvol();
}
inline ::google::protobuf::int32 OptionTick_ser::nvol() const {
  return nvol_;
}
inline void OptionTick_ser::set_nvol(::google::protobuf::int32 value) {
  set_has_nvol();
  nvol_ = value;
}

// optional int32 AskVol = 34 [default = 0];
inline bool OptionTick_ser::has_askvol() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void OptionTick_ser::set_has_askvol() {
  _has_bits_[1] |= 0x00000002u;
}
inline void OptionTick_ser::clear_has_askvol() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void OptionTick_ser::clear_askvol() {
  askvol_ = 0;
  clear_has_askvol();
}
inline ::google::protobuf::int32 OptionTick_ser::askvol() const {
  return askvol_;
}
inline void OptionTick_ser::set_askvol(::google::protobuf::int32 value) {
  set_has_askvol();
  askvol_ = value;
}

// -------------------------------------------------------------------

// Option_collection_ser

// repeated .Serializable.OptionTick_ser option_tick_collection = 1;
inline int Option_collection_ser::option_tick_collection_size() const {
  return option_tick_collection_.size();
}
inline void Option_collection_ser::clear_option_tick_collection() {
  option_tick_collection_.Clear();
}
inline const ::Serializable::OptionTick_ser& Option_collection_ser::option_tick_collection(int index) const {
  return option_tick_collection_.Get(index);
}
inline ::Serializable::OptionTick_ser* Option_collection_ser::mutable_option_tick_collection(int index) {
  return option_tick_collection_.Mutable(index);
}
inline ::Serializable::OptionTick_ser* Option_collection_ser::add_option_tick_collection() {
  return option_tick_collection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Serializable::OptionTick_ser >&
Option_collection_ser::option_tick_collection() const {
  return option_tick_collection_;
}
inline ::google::protobuf::RepeatedPtrField< ::Serializable::OptionTick_ser >*
Option_collection_ser::mutable_option_tick_collection() {
  return &option_tick_collection_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializable

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_OptionTick_2eproto__INCLUDED
