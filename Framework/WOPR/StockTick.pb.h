// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StockTick.proto

#ifndef PROTOBUF_StockTick_2eproto__INCLUDED
#define PROTOBUF_StockTick_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Serializable {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_StockTick_2eproto();
void protobuf_AssignDesc_StockTick_2eproto();
void protobuf_ShutdownFile_StockTick_2eproto();

class StockTick_ser;

// ===================================================================

class StockTick_ser : public ::google::protobuf::Message {
 public:
  StockTick_ser();
  virtual ~StockTick_ser();

  StockTick_ser(const StockTick_ser& from);

  inline StockTick_ser& operator=(const StockTick_ser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StockTick_ser& default_instance();

  void Swap(StockTick_ser* other);

  // implements Message ----------------------------------------------

  StockTick_ser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StockTick_ser& from);
  void MergeFrom(const StockTick_ser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float Bid = 1;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 1;
  inline float bid() const;
  inline void set_bid(float value);

  // optional float Ask = 2;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 2;
  inline float ask() const;
  inline void set_ask(float value);

  // optional float Last = 3;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 3;
  inline float last() const;
  inline void set_last(float value);

  // optional float DailyHigh = 4;
  inline bool has_dailyhigh() const;
  inline void clear_dailyhigh();
  static const int kDailyHighFieldNumber = 4;
  inline float dailyhigh() const;
  inline void set_dailyhigh(float value);

  // optional float DailyLow = 5;
  inline bool has_dailylow() const;
  inline void clear_dailylow();
  static const int kDailyLowFieldNumber = 5;
  inline float dailylow() const;
  inline void set_dailylow(float value);

  // optional float BidSize = 6;
  inline bool has_bidsize() const;
  inline void clear_bidsize();
  static const int kBidSizeFieldNumber = 6;
  inline float bidsize() const;
  inline void set_bidsize(float value);

  // optional float AskSize = 7;
  inline bool has_asksize() const;
  inline void clear_asksize();
  static const int kAskSizeFieldNumber = 7;
  inline float asksize() const;
  inline void set_asksize(float value);

  // optional int32 Volume = 8;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 8;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional int32 DVolume = 9;
  inline bool has_dvolume() const;
  inline void clear_dvolume();
  static const int kDVolumeFieldNumber = 9;
  inline ::google::protobuf::int32 dvolume() const;
  inline void set_dvolume(::google::protobuf::int32 value);

  // optional int32 TotalTrades = 10;
  inline bool has_totaltrades() const;
  inline void clear_totaltrades();
  static const int kTotalTradesFieldNumber = 10;
  inline ::google::protobuf::int32 totaltrades() const;
  inline void set_totaltrades(::google::protobuf::int32 value);

  // optional float LmtPrice = 11;
  inline bool has_lmtprice() const;
  inline void clear_lmtprice();
  static const int kLmtPriceFieldNumber = 11;
  inline float lmtprice() const;
  inline void set_lmtprice(float value);

  // optional string ExDivDate = 12;
  inline bool has_exdivdate() const;
  inline void clear_exdivdate();
  static const int kExDivDateFieldNumber = 12;
  inline const ::std::string& exdivdate() const;
  inline void set_exdivdate(const ::std::string& value);
  inline void set_exdivdate(const char* value);
  inline void set_exdivdate(const char* value, size_t size);
  inline ::std::string* mutable_exdivdate();
  inline ::std::string* release_exdivdate();
  inline void set_allocated_exdivdate(::std::string* exdivdate);

  // optional float ExDivPercentage = 13;
  inline bool has_exdivpercentage() const;
  inline void clear_exdivpercentage();
  static const int kExDivPercentageFieldNumber = 13;
  inline float exdivpercentage() const;
  inline void set_exdivpercentage(float value);

  // optional float ExDivAmount = 14;
  inline bool has_exdivamount() const;
  inline void clear_exdivamount();
  static const int kExDivAmountFieldNumber = 14;
  inline float exdivamount() const;
  inline void set_exdivamount(float value);

  // optional string symbol = 15;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 15;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // @@protoc_insertion_point(class_scope:Serializable.StockTick_ser)
 private:
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_ask();
  inline void clear_has_ask();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_dailyhigh();
  inline void clear_has_dailyhigh();
  inline void set_has_dailylow();
  inline void clear_has_dailylow();
  inline void set_has_bidsize();
  inline void clear_has_bidsize();
  inline void set_has_asksize();
  inline void clear_has_asksize();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_dvolume();
  inline void clear_has_dvolume();
  inline void set_has_totaltrades();
  inline void clear_has_totaltrades();
  inline void set_has_lmtprice();
  inline void clear_has_lmtprice();
  inline void set_has_exdivdate();
  inline void clear_has_exdivdate();
  inline void set_has_exdivpercentage();
  inline void clear_has_exdivpercentage();
  inline void set_has_exdivamount();
  inline void clear_has_exdivamount();
  inline void set_has_symbol();
  inline void clear_has_symbol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float bid_;
  float ask_;
  float last_;
  float dailyhigh_;
  float dailylow_;
  float bidsize_;
  float asksize_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 dvolume_;
  ::google::protobuf::int32 totaltrades_;
  ::std::string* exdivdate_;
  float lmtprice_;
  float exdivpercentage_;
  ::std::string* symbol_;
  float exdivamount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_StockTick_2eproto();
  friend void protobuf_AssignDesc_StockTick_2eproto();
  friend void protobuf_ShutdownFile_StockTick_2eproto();

  void InitAsDefaultInstance();
  static StockTick_ser* default_instance_;
};
// ===================================================================


// ===================================================================

// StockTick_ser

// optional float Bid = 1;
inline bool StockTick_ser::has_bid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StockTick_ser::set_has_bid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StockTick_ser::clear_has_bid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StockTick_ser::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline float StockTick_ser::bid() const {
  return bid_;
}
inline void StockTick_ser::set_bid(float value) {
  set_has_bid();
  bid_ = value;
}

// optional float Ask = 2;
inline bool StockTick_ser::has_ask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StockTick_ser::set_has_ask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StockTick_ser::clear_has_ask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StockTick_ser::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline float StockTick_ser::ask() const {
  return ask_;
}
inline void StockTick_ser::set_ask(float value) {
  set_has_ask();
  ask_ = value;
}

// optional float Last = 3;
inline bool StockTick_ser::has_last() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StockTick_ser::set_has_last() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StockTick_ser::clear_has_last() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StockTick_ser::clear_last() {
  last_ = 0;
  clear_has_last();
}
inline float StockTick_ser::last() const {
  return last_;
}
inline void StockTick_ser::set_last(float value) {
  set_has_last();
  last_ = value;
}

// optional float DailyHigh = 4;
inline bool StockTick_ser::has_dailyhigh() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StockTick_ser::set_has_dailyhigh() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StockTick_ser::clear_has_dailyhigh() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StockTick_ser::clear_dailyhigh() {
  dailyhigh_ = 0;
  clear_has_dailyhigh();
}
inline float StockTick_ser::dailyhigh() const {
  return dailyhigh_;
}
inline void StockTick_ser::set_dailyhigh(float value) {
  set_has_dailyhigh();
  dailyhigh_ = value;
}

// optional float DailyLow = 5;
inline bool StockTick_ser::has_dailylow() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StockTick_ser::set_has_dailylow() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StockTick_ser::clear_has_dailylow() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StockTick_ser::clear_dailylow() {
  dailylow_ = 0;
  clear_has_dailylow();
}
inline float StockTick_ser::dailylow() const {
  return dailylow_;
}
inline void StockTick_ser::set_dailylow(float value) {
  set_has_dailylow();
  dailylow_ = value;
}

// optional float BidSize = 6;
inline bool StockTick_ser::has_bidsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StockTick_ser::set_has_bidsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StockTick_ser::clear_has_bidsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StockTick_ser::clear_bidsize() {
  bidsize_ = 0;
  clear_has_bidsize();
}
inline float StockTick_ser::bidsize() const {
  return bidsize_;
}
inline void StockTick_ser::set_bidsize(float value) {
  set_has_bidsize();
  bidsize_ = value;
}

// optional float AskSize = 7;
inline bool StockTick_ser::has_asksize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StockTick_ser::set_has_asksize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StockTick_ser::clear_has_asksize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StockTick_ser::clear_asksize() {
  asksize_ = 0;
  clear_has_asksize();
}
inline float StockTick_ser::asksize() const {
  return asksize_;
}
inline void StockTick_ser::set_asksize(float value) {
  set_has_asksize();
  asksize_ = value;
}

// optional int32 Volume = 8;
inline bool StockTick_ser::has_volume() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StockTick_ser::set_has_volume() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StockTick_ser::clear_has_volume() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StockTick_ser::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 StockTick_ser::volume() const {
  return volume_;
}
inline void StockTick_ser::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// optional int32 DVolume = 9;
inline bool StockTick_ser::has_dvolume() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StockTick_ser::set_has_dvolume() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StockTick_ser::clear_has_dvolume() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StockTick_ser::clear_dvolume() {
  dvolume_ = 0;
  clear_has_dvolume();
}
inline ::google::protobuf::int32 StockTick_ser::dvolume() const {
  return dvolume_;
}
inline void StockTick_ser::set_dvolume(::google::protobuf::int32 value) {
  set_has_dvolume();
  dvolume_ = value;
}

// optional int32 TotalTrades = 10;
inline bool StockTick_ser::has_totaltrades() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StockTick_ser::set_has_totaltrades() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StockTick_ser::clear_has_totaltrades() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StockTick_ser::clear_totaltrades() {
  totaltrades_ = 0;
  clear_has_totaltrades();
}
inline ::google::protobuf::int32 StockTick_ser::totaltrades() const {
  return totaltrades_;
}
inline void StockTick_ser::set_totaltrades(::google::protobuf::int32 value) {
  set_has_totaltrades();
  totaltrades_ = value;
}

// optional float LmtPrice = 11;
inline bool StockTick_ser::has_lmtprice() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StockTick_ser::set_has_lmtprice() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StockTick_ser::clear_has_lmtprice() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StockTick_ser::clear_lmtprice() {
  lmtprice_ = 0;
  clear_has_lmtprice();
}
inline float StockTick_ser::lmtprice() const {
  return lmtprice_;
}
inline void StockTick_ser::set_lmtprice(float value) {
  set_has_lmtprice();
  lmtprice_ = value;
}

// optional string ExDivDate = 12;
inline bool StockTick_ser::has_exdivdate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StockTick_ser::set_has_exdivdate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StockTick_ser::clear_has_exdivdate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StockTick_ser::clear_exdivdate() {
  if (exdivdate_ != &::google::protobuf::internal::kEmptyString) {
    exdivdate_->clear();
  }
  clear_has_exdivdate();
}
inline const ::std::string& StockTick_ser::exdivdate() const {
  return *exdivdate_;
}
inline void StockTick_ser::set_exdivdate(const ::std::string& value) {
  set_has_exdivdate();
  if (exdivdate_ == &::google::protobuf::internal::kEmptyString) {
    exdivdate_ = new ::std::string;
  }
  exdivdate_->assign(value);
}
inline void StockTick_ser::set_exdivdate(const char* value) {
  set_has_exdivdate();
  if (exdivdate_ == &::google::protobuf::internal::kEmptyString) {
    exdivdate_ = new ::std::string;
  }
  exdivdate_->assign(value);
}
inline void StockTick_ser::set_exdivdate(const char* value, size_t size) {
  set_has_exdivdate();
  if (exdivdate_ == &::google::protobuf::internal::kEmptyString) {
    exdivdate_ = new ::std::string;
  }
  exdivdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockTick_ser::mutable_exdivdate() {
  set_has_exdivdate();
  if (exdivdate_ == &::google::protobuf::internal::kEmptyString) {
    exdivdate_ = new ::std::string;
  }
  return exdivdate_;
}
inline ::std::string* StockTick_ser::release_exdivdate() {
  clear_has_exdivdate();
  if (exdivdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exdivdate_;
    exdivdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StockTick_ser::set_allocated_exdivdate(::std::string* exdivdate) {
  if (exdivdate_ != &::google::protobuf::internal::kEmptyString) {
    delete exdivdate_;
  }
  if (exdivdate) {
    set_has_exdivdate();
    exdivdate_ = exdivdate;
  } else {
    clear_has_exdivdate();
    exdivdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float ExDivPercentage = 13;
inline bool StockTick_ser::has_exdivpercentage() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StockTick_ser::set_has_exdivpercentage() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StockTick_ser::clear_has_exdivpercentage() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StockTick_ser::clear_exdivpercentage() {
  exdivpercentage_ = 0;
  clear_has_exdivpercentage();
}
inline float StockTick_ser::exdivpercentage() const {
  return exdivpercentage_;
}
inline void StockTick_ser::set_exdivpercentage(float value) {
  set_has_exdivpercentage();
  exdivpercentage_ = value;
}

// optional float ExDivAmount = 14;
inline bool StockTick_ser::has_exdivamount() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StockTick_ser::set_has_exdivamount() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StockTick_ser::clear_has_exdivamount() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StockTick_ser::clear_exdivamount() {
  exdivamount_ = 0;
  clear_has_exdivamount();
}
inline float StockTick_ser::exdivamount() const {
  return exdivamount_;
}
inline void StockTick_ser::set_exdivamount(float value) {
  set_has_exdivamount();
  exdivamount_ = value;
}

// optional string symbol = 15;
inline bool StockTick_ser::has_symbol() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StockTick_ser::set_has_symbol() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StockTick_ser::clear_has_symbol() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StockTick_ser::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& StockTick_ser::symbol() const {
  return *symbol_;
}
inline void StockTick_ser::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void StockTick_ser::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void StockTick_ser::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StockTick_ser::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* StockTick_ser::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StockTick_ser::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializable

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StockTick_2eproto__INCLUDED
